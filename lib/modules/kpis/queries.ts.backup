'use server'

import { createClient } from '@/lib/supabase/server'
import type { KPI, KPIStats, KPISummary } from './types'

/**
 * Get all KPIs with user info
 * Admins see all, members see only their own
 */
export async function getKPIs(): Promise<KPI[]> {
    const supabase = await createClient()

    const { data, error } = await supabase
        .from('kpis')
        .select(`
      *,
      user:profiles!kpis_user_id_fkey (
        id,
        full_name,
        email,
        position
      ),
      creator:profiles!kpis_created_by_fkey (
        id,
        full_name
      )
    `)
        .order('created_at', { ascending: false })

    if (error) {
        console.error('Error fetching KPIs:', error)
        return []
    }

    return data || []
}

/**
 * Get KPIs for a specific user
 */
export async function getUserKPIs(userId: string): Promise<KPI[]> {
    const supabase = await createClient()

    const { data, error } = await supabase
        .from('kpis')
        .select(`
      *,
      user:profiles!kpis_user_id_fkey (
        id,
        full_name,
        email,
        position
      ),
      creator:profiles!kpis_created_by_fkey (
        id,
        full_name
      )
    `)
        .eq('user_id', userId)
        .order('created_at', { ascending: false })

    if (error) {
        console.error('Error fetching user KPIs:', error)
        return []
    }

    return data || []
}

/**
 * Get active KPIs (within current date range)
 */
export async function getActiveKPIs(): Promise<KPI[]> {
    const supabase = await createClient()
    const today = new Date().toISOString().split('T')[0]

    const { data, error } = await supabase
        .from('kpis')
        .select(`
      *,
      user:profiles!kpis_user_id_fkey (
        id,
        full_name,
        email,
        position
      )
    `)
        .lte('start_date', today)
        .gte('end_date', today)
        .order('created_at', { ascending: false })

    if (error) {
        console.error('Error fetching active KPIs:', error)
        return []
    }

    // Auto-track logic
    const enrichedKPIs = await Promise.all(data.map(async (kpi) => {
        if (!kpi.auto_track) return kpi

        let count = 0

        if (kpi.kpi_type.startsWith('content_')) {
            // Content Tracking
            let type = ''
            if (kpi.kpi_type === 'content_videos') type = 'video'
            else if (kpi.kpi_type === 'content_articles') type = 'blog_post' // Assuming articles maps to blog_post
            else if (kpi.kpi_type === 'content_images') type = 'social_post' // Assuming images maps to social_post? User said "Số Video". Let's stick to video/blog_post. 
            // Better to map granularly or check if generic 'content' type.
            // Let's assume broad mapping for now or default to 'social_post' for others.
            // Screenshot 1 has "Số Video".
            // Let's refine mapping:
            const typeMap: Record<string, string> = {
                'content_videos': 'video',
                'content_articles': 'blog_post',
                'content_images': 'social_post'
            }
            type = typeMap[kpi.kpi_type] || 'social_post'

            const { count: contentCount } = await supabase
                .from('content_items')
                .select('id', { count: 'exact', head: true })
                .eq('assignee_id', kpi.user_id)
                .in('status', ['published', 'completed'])
                .eq('type', type)
                .gte('scheduled_date', kpi.start_date)
                .lte('scheduled_date', kpi.end_date + 'T23:59:59')

            count = contentCount || 0
        } else {
            // Task Tracking (Default 'other' or 'leads' if mapped)
            // User requested "Tasks Module" tracking
            const { count: taskCount } = await supabase
                .from('tasks')
                .select('id', { count: 'exact', head: true })
                .eq('assigned_to', kpi.user_id) // tasks table uses assigned_to
                .eq('status', 'done')
                .gte('updated_at', kpi.start_date) // Using updated_at for completion time? Or created_at? User specifically said "Task Done", usually means when it was finished. But DB might not store finished_at. using updated_at is defined as decent proxy if status changed.
                .lte('updated_at', kpi.end_date + 'T23:59:59')

            count = taskCount || 0
        }

        // Only update display value, do NOT write back to DB (to avoid race conditions/perf). 
        // Admin calculates payroll based on this view.
        return {
            ...kpi,
            current_value: count
        }
    }))

    return enrichedKPIs || []
}

/**
 * Get a single KPI by ID
 */
export async function getKPIById(id: string): Promise<KPI | null> {
    const supabase = await createClient()

    const { data, error } = await supabase
        .from('kpis')
        .select(`
      *,
      user:profiles!kpis_user_id_fkey (
        id,
        full_name,
        email,
        position
      ),
      creator:profiles!kpis_created_by_fkey (
        id,
        full_name
      )
    `)
        .eq('id', id)
        .single()

    if (error) {
        console.error('Error fetching KPI:', error)
        return null
    }

    return data
}

/**
 * Get KPI statistics
 */
export async function getKPIStats(): Promise<KPIStats> {
    const kpis = await getActiveKPIs()

    const stats = kpis.reduce(
        (acc, kpi) => {
            const percentage = kpi.target_value > 0
                ? (kpi.current_value / kpi.target_value) * 100
                : 0

            acc.total++

            if (percentage >= 100) {
                acc.completed++
            } else if (percentage >= 80) {
                acc.on_track++
            } else if (percentage >= 50) {
                acc.at_risk++
            } else {
                acc.behind++
            }

            return acc
        },
        { total: 0, on_track: 0, at_risk: 0, behind: 0, completed: 0 }
    )

    return stats
}

/**
 * Get KPI summary by user
 */
export async function getKPISummaryByUser(): Promise<KPISummary[]> {
    const kpis = await getActiveKPIs()

    // Group by user
    const userMap = new Map<string, KPISummary>()

    kpis.forEach((kpi) => {
        if (!kpi.user) return

        const userId = kpi.user.id
        if (!userMap.has(userId)) {
            userMap.set(userId, {
                user_id: userId,
                user_name: kpi.user.full_name,
                position: kpi.user.position,
                total_kpis: 0,
                completed: 0,
                on_track: 0,
                at_risk: 0,
                behind: 0,
                avg_completion: 0,
            })
        }

        const summary = userMap.get(userId)!
        const percentage = kpi.target_value > 0
            ? (kpi.current_value / kpi.target_value) * 100
            : 0

        summary.total_kpis++

        if (percentage >= 100) {
            summary.completed++
        } else if (percentage >= 80) {
            summary.on_track++
        } else if (percentage >= 50) {
            summary.at_risk++
        } else {
            summary.behind++
        }
    })

    // Calculate average completion
    userMap.forEach((summary) => {
        const userKPIs = kpis.filter(k => k.user?.id === summary.user_id)
        const totalPercentage = userKPIs.reduce((sum, kpi) => {
            return sum + (kpi.target_value > 0 ? (kpi.current_value / kpi.target_value) * 100 : 0)
        }, 0)
        summary.avg_completion = userKPIs.length > 0
            ? Math.round(totalPercentage / userKPIs.length)
            : 0
    })

    return Array.from(userMap.values())
}

/**
 * Get KPI history for charts
 */
export async function getKPIHistory(kpiId: string) {
    const supabase = await createClient()

    const { data, error } = await supabase
        .from('kpi_history')
        .select('*')
        .eq('kpi_id', kpiId)
        .order('recorded_at', { ascending: true })

    if (error) {
        console.error('Error fetching KPI history:', error)
        return []
    }

    return data || []
}
